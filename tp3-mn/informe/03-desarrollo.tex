\section{Desarrollo}

Como explicamos en la introducción estaremos analizando 4 algoritmos distintos, estos son: Vecinos, Bilineal, Direccional y High Quality. La idea será comparar sus resultados subjetivamente, es decir a simple vista como 
vemos la imagen resultante, objetivamente y temporalmente, osea cuanto tiempo demora en ejecutarse el procedimiento, para poder concluir finalmente las ventajas y desventajas de cada uno. A continuación explicaremos como 
implementamos cada uno.

\subsection{Vecinos}
Este es el más simple de todos. La idea es estabelecer el valor de los colores faltantes de cada pixel en base al vecino que tenga dicho valor. Por ejemplo si estamos en un pixel azul le preguntamos a algun vecino rojo y 
otro verde su valor y los seteamos en los correspondientes colores de nuestro pixel.

Pseudocódigo:
\begin{lstlisting}[frame=single] 
Para cada celda:
	si es roja:
		celda.verde = vecinoIzq.verde
		celda.azul  = vecinoSuperiorIzq.azul	
	si es azul:
		celda.rojo = vecinoInferiorDerecho.rojo
		celda.verde = vecinoDerecho.verde
	si es verde y fila par:
		celda.rojo = vecinoDerecho.rojo
		celda.azul = vecinoSuperior.azul
	si es verde y fila impar:
		celda.rojo = vecinoInferior.rojo
		celda.azul = vecinoIzquierdo.azul
\end{lstlisting}

Se diferencia entre fila par e impar cuando la celda es verde ya que es distinta la disposición de sus vecinos en cada caso, esto en cambio se mantiene inmutable en los casos de celda roja o azul. La selección del
vecino izquierdo y superior izquierdo cuando es roja es porque siempre existe ese vecino, a diferencia del derecho por ejemplo ya que el rojo puede ser una celda borde y no tener dicho adyacente. La misma idea aplicamos 
al caso de la celda azul y de las verdes, apuntamos a elegir el vecino que siempre existe.

\subsection{Bilineal}

\subsection{Direccional}

Para este algoritmo nos basamos en lo explicado por Burden y Faires$[1]$ para el caculo de los splines y en lo desarrollado por Ron Kimmel$[2]$ para el algoritmo en sí. El método lo aplicamos sólo para el color verde mientras que para los otros utilizamos bilineal. 

Lo que hace es:
\begin{lstlisting}[frame=single] 
Para cada celda:
	Interpolo mediante spline su fila y columna
	Calculo sus derivadas aproximadas en direcci\'on horizontal y vertical
	Si la derivada horizontal es mayor
		celda.verde = interpolaci\'on horizontal * 0.3 +  interpolaci\'on vertical *  0.7
	sino
		celda.verde = interpolaci\'on horizontal * 0.3 +  interpolaci\'on vertical * 0.7	
\end{lstlisting}

Dado que las interpolaciones mediante splines no son nada triviales lo explicaremos mas adelante en detalle. Las derivadas en $x$  la aproximamos haciendo $|G(x-1,y)-G(x+1,y)|$ donde G es el valor del color verde en ese punto, la derivada en $y$ es análoga. Dado que un mayor valor en la derivada puede estar indicándonos un potencial borde le damos mayor peso a la derivada cuyo valor es más chico multiplicando a este por 0.7 y a la otra por 0.3. Finalmente las sumamos para obtener el verde correspondiente en nuestra celda.

\subsection{High Quality}

Todos los algoritmos anteriores aproximaban el valor mediante un color, pero esto no era suficiente para darle definición ya que muchas veces los colores tienen un brillo o luz que impacta en todos, por lo tanto... 

El algoritmo de demosaicing que denominamos "High Quality" se basa en el paper de Malvar, He y Cutler. Su principal atractivo es que realiza una corrección de la imagen luego de aplicar el algoritmo de Interpolación Bilineal pero teniendo en cuenta para calcular un color a los otros dos, en diferencia a los otros algoritmos que solo tienen en cuenta los valores cercanos con respecto a su mismo color.



Para el algoritmo highquality decidimos solamente procesar el color verde de los pixeles ya que solamente medimos la calidad de ese color en el tp.

- Primero hacemos bilineal sobre todos los colores de la imagen
- Por cada pixel de la imagen (exceptuando los bordes):
	- Si la imagen cae en verde la ignoro
	- Si cae en rojo o azul:
		- Al color verde de ese pixel le sumo el valor del color actual calculado en la bilineal
		- 
		
	


