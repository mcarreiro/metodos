\section{Desarrollo}

\subsection{Matriz Banda}

Como explicamos en la introducción de la matriz banda, llegamos a la conclusión de que la matriz de ecuaciones de la representación del parabrisas tenía forma de la denominada "matriz banda" cuya respectiva banda era de tamaño m+m+1 con m siendo el ancho del parabrisas. Este es un hecho importante ya que las matrices banda tienen caracteristicas especiales de las cuales es posible la optimización temporal y espacial para resolver el sistema de ecuaciones con eliminación gausseana.

\subsubsection{Optimización espacial}

El problema de representar la matriz original es que la mayoría de los valores son 0 y solo importan los elementos de la banda de la matriz, por lo tanto una forma de optimizar espacialmente es solo guardar la banda, con lo que se logra reducir considerablemente el espacio en esta representación, ya que suponiendo que se tiene un parabrisas de n filas y m columnas, el tamaño de la matriz original sería de (n*m)^2, mientras que con la optimización de matriz banda quedaría de tamaño (n*m)*(2*m+1)

\subsubsection{Optimización temporal}
\subsubsection{Ejemplo}
\begin{verbatim}

por cada posición del parabrisas
		pos = fila posicion + columna posicion * ancho;
		
		si en esa posición hay una SANGUIJUELA:
			
			bandMatrix[pos][ancho] = 1;
			bandMatrix[pos][res] = ts;
		
		si esa posición es borde FRIO:
			bandMatrix[pos][ancho] = 1;
			bandMatrix[pos][res] = -100;


		en caso de que esa posición sea VACIA:
			bandMatrix[pos][ancho] = -4;
			bandMatrix[pos][res] = 0;
			if(matrix[i][j-1]->status != VACIO) bandMatrix[pos][res] -= matrix[i][j-1]->temp;
			else bandMatrix[pos][ancho-1] = 1;

			if(matrix[i-1][j]->status != VACIO) bandMatrix[pos][res] -= matrix[i-1][j]->temp;
			else bandMatrix[pos][0] = 1;

			if(matrix[i][j+1]->status != VACIO) bandMatrix[pos][res] -= matrix[i][j+1]->temp;
			else bandMatrix[pos][ancho+1] = 1;

			if(matrix[i+1][j]->status != VACIO) bandMatrix[pos][res] -= matrix[i+1][j]->temp;
			else bandMatrix[pos][ancho*2] = 1;
		

\end{verbatim}
\begin{figure}[htb]
\begin{center}
\includegraphics[scale=0.70]{imagenes/parabrisasej.png} 
\caption{Vista de la representación de Parabrisas del ejemplo} 
\end{center}
\end{figure}

\begin{figure}[htb]
\begin{center}
\includegraphics[scale=0.70]{imagenes/matrizej.png} 
\caption{Matriz de ecuaciones del ejemplo} 
\end{center}
\end{figure}

\begin{figure}[htb]
\begin{center}
\includegraphics[scale=0.70]{imagenes/matrizbandaej.png} 
\caption{Matriz banda del ejemplo} 
\end{center}
\end{figure}


\subsection{Soluciones}

Para resolver el problema que se nos pide, seleccionar que sanguijuelas matar, pensamos una soluciòn Greedy  (\ref{sec:MatrizCuadrada}) + Local Search . Esta consiste, a grandes rasgos, en ir matando las sanguijuelas del medio (ya que son las que mayor temperatura generan en el punto crìtico) hasta que el punto central este por debajo del 235 Cº. Para tener algún parámetro de referencia pensamos en buscar otra solución posible, y asì  compararlas y chequear que esta sea mejor. Esta solución alternativa consiste básicamente en seleccionar aleatoriamente que sanguijuelas aniquilar. Procederemos ahora a explicar en detalle las implementaciones de estas soluciones.

\subsection{Solución GRASP}


\subsection{Solución Random}\label{sec:solucionRandom}


En esta solución seleccionamos de nuestro array de posiciones de sanguijuelas (que es el array recibido por parametro, osea con las posiciones sin discretizar) una al azar y la eliminamos. Luego ejecutamos de nuevo el cálculo de las temperaturas y chequeamos si el punto crìtico esta por debajo del 235 Cº.Si no lo está, elegimos otra al azar y repetimos el proceso hasta que lo esté. 

Pseudocodigo:

\begin{verbatim}
Class Windshield{
    randomSolution(){
         while(!this->isCooledDown(){
             this->randomKill()
         }
    } 
    isCooledDown(){
         return (matrix.centerPoint < Ts)
    }
    randomKill(){
         randomRemove(posSanguijuelas)
         this->recalculateTemps()
    }
}
\end{verbatim}

Vale aclarar que el recalculateTemps utiliza el metodo band matrix, ya que este es màs rápido.









